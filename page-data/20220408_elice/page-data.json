{
    "componentChunkName": "component---src-templates-blog-post-js",
    "path": "/20220408_elice/",
    "result": {"data":{"site":{"siteMetadata":{"title":"HyoungMin's mini-log"}},"markdownRemark":{"id":"2f44cf90-cfd8-5170-a5b8-31dcc5361c0f","excerpt":"Git 00. Git을 사용하는 이유 효율적인 협업을 위해 Git…","html":"<h1>Git</h1>\n<h2>00. Git을 사용하는 이유</h2>\n<h3>효율적인 협업을 위해 Git을 사용한다.</h3>\n<p>여러 개발자가 동시에 작업을 하는 과정에서, 각각 개발자가 업로드한 버전이 다르기 때문에 한 개발자가 변경한 버전이 사라질 수도 있고, 동시에 하나의 파일을 수정하는 경우 각 개발자가 수정한 파일을 하나로 병합할 필요성이 있다.</p>\n<h3>쉬운 버전 관리를 위해 Git을 사용한다.</h3>\n<p>Git은 각 파일을 snapshot으로 저장하기 때문에 버전 관리에 용이하므로, 백업 파일을 지속적으로 만드는 것보다 쉽고 효율적으로 버전 관리를 할 수 있고, 데이터의 안정성이 보장된다.</p>\n<h3>오픈 소스로 누구나 사용할 수 있다.</h3>\n<h2>01. Git의 특징</h2>\n<h3>가지치기와 병합이 자유롭다.</h3>\n<p>때로는 여러 작업이 동시에 할 수 있는데, 혼합되면 안되는 상황이 존재한다. 이때 Git이 메인 코드(master branch)에서 독립성을 유지한 채 다른 개발 작업을 진행할 수 있게 해주고, 이를 병합하여 메인 코드로 반영한 후 배포할 수 있다.\r\n즉, 각각의 작업이 독립성이 유지되어 협업에 유리하다.</p>\n<h3>가볍고 빠르다.</h3>\n<p>서버가 아닌 로컬에서 진행되기 때문에 가볍고 빠르게 진행된다. 다른 사람과 코드를 공유하는 시점에만 중앙 서비스에 접속하면 되기 때문에 네트워크 속도에 관계 없이 빠르게 진행할 수 있다.</p>\n<h3>분산 작업에 효율적이다.</h3>\n<p>각 개발자는 복사된 프로젝트에서 동시에 작업을 진행할 수 있고, 전체 프로젝트의 모든 코드를 가지고 있으므로, 서로 단절되더라도 개발에 문제가 없다. 추가로 따로 통합 관리자를 두어 병합의 역할에 집중할 수 있다.</p>\n<p>파일의 차이점을 기록하는 서버형 버전 관리 시스템인 SVN과 달리 Git은 각 개발자가 중앙 집중된 서버 저장소와 독립된 상태로 작업할 수 있고, 네트워크 사용이 적다.(각자 온전한 프로젝트 파일을 가지고 있고, 스냅샷 형태로 관리하며 각 작업자들의 버전 히스토리를 가질 수 있다.)</p>\n<h3>프로젝트의 무결성을 보장할 수 있다.</h3>\n<p>Commit ID가 동일하면, 파일과 구성이 완벽히 동일한 것이다. 따라서 누가 어떤 파일을 작업했는지 확실히 알 수 있고, 데이터가 보장된다.</p>\n<h3>준비 영역을 통해 검토에 유리하다.</h3>\n<blockquote>\n<p>Working Directory -> Staging Area -> Repository</p>\n</blockquote>\n<p>staging area에 <code class=\"language-text\">git add</code>하고, 검토한 후에 <code class=\"language-text\">git commit</code> 명령어를 통해 레포지토리에 업로드할 수 있다.</p>\n<h3>오픈소스이다.</h3>\n<p>공개된 오픈소스로, 누구나 기여할 수 있다.</p>\n<h2>02. Git 설치 및 초기 설정</h2>\n<p><a href=\"https://git-scm.com/downloads\">여기</a>서 본인의 컴퓨터에 맞는 설치 파일을 다운로드하고, 이를 실행하면 된다.\r\n이후 Git Bash(윈도우 기준)을 실행하고, 버전을 확인하면 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">git version</code></pre></div>\n<p>잘 설치가 된 것을 확인하면, 사용자 정보를 설정해야 한다. 저장소에 코드를 반영할 때 등록될 사용자 정보를 설정해야 한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">git config --global user.name \"이름\"\r\ngit config --global user.email 이메일</code></pre></div>\n<p>사용자 정보를 설정했다면, 다음 명령어를 통해 설정한 내용을 확인할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">git config --list</code></pre></div>\n<h3>📝 실습 01 | Git 버전 확인</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">git version</code></pre></div>\n<h3>📝 실습 02 | Git 유저 설정</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">git config --global user.name \"elice\"\r\ngit config --global user.email \"rabbit@elice.io\"\r\ngit config --list</code></pre></div>\n<h2>03. Git 저장소 생성</h2>\n<p>다음 명령어를 통해 기존 디렉토리를 git 레포지토리로 설정할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">cd 기존 디렉토리 경로\r\ngit init</code></pre></div>\n<p>혹은 다음 명령어를 통해 이동하지 않고 생성할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">git init 기존 디렉토리 경로</code></pre></div>\n<p>해당 디렉토리로 이동 후 다음 명령어로 전체 파일을 살펴보면 <code class=\"language-text\">.git</code> 디렉토리가 생성되며 레포지토리가 생성되었음을 확인할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">ls -al</code></pre></div>\n<h3>📝 실습 03 | Git 저장소 생성</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">git init\r\ngit init ./temporary/elice</code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">ls -al</code></pre></div>\n<h3>📝 실습 04 | 여러 개의 Git 저장소 생성</h3>\n<p><code class=\"language-text\">project1</code> 저장소 생성</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">git init project1</code></pre></div>\n<p><code class=\"language-text\">mydir</code> 디렉토리로 이동한 후 <code class=\"language-text\">hello</code> 저장소 생성</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">cd mydir\r\ngit init hello</code></pre></div>\n<p><code class=\"language-text\">world</code> 디렉토리로 이동한 후 Git 저장소 생성</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">cd world\r\ngit init</code></pre></div>\n<p>혹은</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">git init ./world</code></pre></div>\n<h2>04. Git 파일 생성(<code class=\"language-text\">git add</code>)</h2>\n<p>우선, 다음 명령어로 새롭게 작업한 파일 <code class=\"language-text\">comment.js</code>를 Staging Area으로 보내야 한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">git add comment.js</code></pre></div>\n<p>Staging Area으로 보낼 파일이 많다면, 현재 디렉토리의 모든 대상을 한 번에 보낼 수도 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">git add .</code></pre></div>\n<p>이후, 다음 명령어를 통해 Staging Area의 어떤 파일이 변경되었는지 등의 파일의 상태를 확인할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">git status</code></pre></div>\n<h2>05. Git 저장소 반영(<code class=\"language-text\">git commit</code>)</h2>\n<p>다음 명령어를 통해 Staging Area에 올린 파일에 무엇을 수정하고 추가했는지에 대해 메시지를 남겨 저장소에 저장할 수 있다. 다만 이 명령어는 <code class=\"language-text\">.git</code> 저장소 내의 모든 Staging 파일을 저장소로 반영한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">git commit</code></pre></div>\n<p>반영한 내용을 추후에 쉽게 알 수 있도록 적절한 커밋 메시지를 작성할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">git commit -m \"commitMessage\"</code></pre></div>\n<p>메시지 오타, 파일 누락 등 반영 내용을 수정하고 싶을 때는 다음 명령어를 통해 텍스트 편집기를 실행하여 수정한 후 저장하면 그대로 반영된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">git commit --amend -m \"수정할 커밋 명\"</code></pre></div>\n<p>저장소 반영 내역은 다음 명령어를 통해 확인할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">git log</code></pre></div>\n<h3>📝 실습 05 | Git 저장소 생성 및 커밋</h3>\n<p>Staging Area에 <code class=\"language-text\">main.py</code> 파일 추가</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">git add main.py</code></pre></div>\n<p>Staging Area 확인</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">git status</code></pre></div>\n<p>Staging Area의 파일 커밋</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">git commit -m \"Initial commit\"</code></pre></div>\n<p>커밋 기록 확인</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">git log</code></pre></div>\n<h2>06. Git 관리 상태 확인</h2>\n<h3><code class=\"language-text\">git status</code>, <code class=\"language-text\">git diff</code></h3>\n<p>다음 명령어를 통해 Staging Area에 있는 Staging Files의 상태를 확인할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">git status</code></pre></div>\n<p>커밋된 파일 중 변경된 사항을 비교하려면 다음 명령어를 활용하면 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">git diff</code></pre></div>\n<h3><code class=\"language-text\">git log</code></h3>\n<p>다음 명령어로는 <code class=\"language-text\">.git</code> 저장소에 모든 커밋 반영 내역을 확인할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">git log</code></pre></div>\n<h4><code class=\"language-text\">-p</code>, <code class=\"language-text\">-patch</code></h4>\n<p>각 커밋의 수정 결과를 보여주는 diff와 동일한 역할을 수행하는 옵션</p>\n<h4><code class=\"language-text\">-n</code></h4>\n<p>상위 n개의 커밋만 출력하게끔 설정하는 옵션</p>\n<h4><code class=\"language-text\">--stat</code></h4>\n<p>어떤 파일이 커밋에서 수정되고 변경되었는지, 파일 내 라인의 추가/삭제를 확인하는 옵션</p>\n<h4><code class=\"language-text\">--pretty=oneline</code></h4>\n<p>각 커밋을 한 줄로 출력하게끔 설정하는 옵션</p>\n<h4><code class=\"language-text\">--graph</code></h4>\n<p>커밋 간의 연결 관계를 아스키 그래프로 출력하는 옵션, Branch에서 유용하게 활용된다.</p>\n<h4><code class=\"language-text\">-S text</code></h4>\n<p>코드에서 추가되거나 제거된 내용 중 특정 텍스트(text)가 포함되어 있는지 검사하는 옵션</p>\n<h3>🚩 퀴즈 02 | Git 파일의 상태</h3>\n<p>Git 파일의 상태를 확인한 후 staging을 취소하기 위해서는 다음 명령어가 필요하다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">git reset HEAD README.txt</code></pre></div>\n<p>이후 수정된 파일을 저장소에 커밋하려면 처음부터 시작해야 한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">git add crawling.py\r\ngit commit -m \"add crawling.py\"</code></pre></div>\n<h3>📝 실습 06 | 현재 상황 확인</h3>\n<p>git 저장소의 현재 상태 확인</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">git status</code></pre></div>\n<h3>📝 실습 07 | 원하는 파일 커밋</h3>\n<p>원하지 않는 파일이 Staging Area에 있는 경우 제거</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">git reset README.txt</code></pre></div>\n<p>이후 원하는 파일만 Staging Area에 추가</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">git add crawling.py rat.py</code></pre></div>\n<h3>🚩 퀴즈 03 | Git 파일의 생명 주기</h3>\n<p><code class=\"language-text\">git add</code> 명령을 거친 파일은 Staged 상태가 된다.\r\nUntracked 파일을 Git에 추가하려면 <code class=\"language-text\">add</code>해야 한다.\r\nUnmodified 파일은 항상 Git 저장소에 있는 파일과 내용이 같다.\r\nModified 파일들의 갱신된 내역을 저장소에 반영하려면 <code class=\"language-text\">add</code>, <code class=\"language-text\">commit</code> 과정을 거쳐야 한다.</p>\n<h2>07. Git 가지치기</h2>\n<h3>Git Branch</h3>\n<p>Branch는 독립적으로 어떤 작업을 진행하는 가지를 의미한다. 각각의 Branch는 다른 Branch의 영향을 받지 않는다.\r\n특히, <code class=\"language-text\">master</code> Branch에서 프로젝트의 메인 파일을 가지고 있는데, 개발 목적의 새로운 <code class=\"language-text\">develop</code> Branch를 생성하여 작업한 후 배포를 위해 다시 <code class=\"language-text\">master</code> Branch와 병합하여 배포한다. 또한, 새로운 문제가 발생할 때마다 해당 문제를 가지고 새로운 Branch를 생성해 개발을 진행할 수 있다.</p>\n<h3>Git Branch 종류</h3>\n<ul>\n<li>메인 Branch: 배포할 수 있는 수준의 안정적인 Branch</li>\n<li>토픽 Branch: 기능 추가, 버그 수정 등의 단위 작업을 위한 Branch</li>\n</ul>\n<h3>Git Branch 생성</h3>\n<p>다음 명령어를 통해 Git Branch를 생성할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">git branch branchName</code></pre></div>\n<p><code class=\"language-text\">master</code> Branch는 Git 저장소를 생성할 때 기본적으로 생성되는 기본 Branch이다.</p>\n<h3>Git Branch 전환</h3>\n<p>현재 존재하는 Branch를 확인하기 위해서는 다음 명령어를 활용해야 한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">git branch</code></pre></div>\n<p>이후 다음 명령어로 Branch를 전환할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">git checkout branchName</code></pre></div>\n<p>다만, <code class=\"language-text\">checkout</code> 명령어는 <code class=\"language-text\">git log</code> 명령어로 확인한 스냅샷의 16진수 Hash Number를 활용해 스냅샷을 전환할 때도 활용된다. 이를 통해 과거의 파일 내용을 확인할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">git checkout snapshotHashCode</code></pre></div>\n<p>HEAD 포인터는 현재 위치를 의미한다.</p>\n<h3>🚩 퀴즈 01 | Git Branch</h3>\n<p>Git Branch란 독립적으로 어떤 작업을 진행하기 위한 개념이다.\r\n각각의 Branch는 다른 Branch의 영향을 받지 않는다.\r\nBranch 생성은 <code class=\"language-text\">git branch &lt;branch 명></code>으로 가능하다.\r\nBranch 생성 후 전환은 <code class=\"language-text\">git checkout &lt;branch 명></code>으로 가능하다.</p>\n<h3>fast forward</h3>\n<p>새로운 Branch에서 진행한 작업을 커밋하면, 해당 체크포인트가 생성된다.</p>\n<h3>Git merge</h3>\n<p>새로운 Branch에서 작업을 마친 후에 master Branch로 이동하여 새로운 Branch를 병합해야 한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">git checkout master\r\ngit merge newBranch</code></pre></div>\n<p>결과적으로 <code class=\"language-text\">newBranch</code>의 작업 내용이 <code class=\"language-text\">master</code> Branch로 병합되고, 새로운 체크포인트(<code class=\"language-text\">C3</code>)가 생성된다. 그러면 사실상 두 Branch가 동일해진다. 이때 <code class=\"language-text\">newBranch</code>의 작업 내용이 <code class=\"language-text\">master</code> Branch의 내용에 단순히 추가되는 업데이트 사항이라면 곧바로 병합되는데, 이를 fast forward라고 한다. 이와 달리, 같은 파일의 내용이 다르게 수정되는 경우(독립적으로 운용되기 때문에 같은 파일의 내용이 수정될 수 있다.)에는 문제가 생길 수 있다.</p>\n<p>이때는 우선 갈라지는 Branch를 확인하기 위해 다음 명령어를 활용해야 한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">git log --graph --all</code></pre></div>\n<p>이후 <code class=\"language-text\">master</code> Branch로 이동하여 새로운 <code class=\"language-text\">newBranch</code>를 병합하면 새로운 체크포인트(<code class=\"language-text\">C5</code>)가 생성된다. 이때, 유의할 점은 fast-forward와 달리 동시에 각 Branch에서 작업이 진행되므로, 체크포인트가 두 개(<code class=\"language-text\">C3</code>, <code class=\"language-text\">C4</code>)가 생성되고, 이후 병합한 이후에는 <code class=\"language-text\">newBranch</code>는 수정한 체크포인트 <code class=\"language-text\">C3</code>에 머물러있는 반면, 병합한 <code class=\"language-text\">master</code> Branch는 병합된 체크포인트 <code class=\"language-text\">C5</code>에 존재하여 두 내용이 다르게 된다.</p>\n<p>병합된 Branch는 다음 명령어로 확인할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">git branch --merged</code></pre></div>\n<p>또한, 일반적으로 사용을 마친 Branch는 다음 명령어를 통해 삭제한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">git branch -d branchName</code></pre></div>\n<h3>Git Merge Conflict 해결</h3>\n<p>병합한 두 Branch에서 같은 파일을 변경할 때 충돌이 발생한다. 이러한 경우 다음 명령어를 통해 충돌이 일어난 파일명을 확인할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">git status</code></pre></div>\n<p>해당 파일의 문제가 되는 부분을 확인하면 <code class=\"language-text\">&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>,<code class=\"language-text\">=======</code>,<code class=\"language-text\">>>>>>>></code>등의 기호를 확인할 수 있는데, 내용의 충돌을 수정하고 이 부분을 지워주어야 한다. 이후 다시 <code class=\"language-text\">git add</code>와 <code class=\"language-text\">git commit</code> 과정을 거쳐 새롭게 병합해주어야 한다.</p>\n<h2>08. Git 원격 저장소</h2>\n<h3>원격 저장소</h3>\n<p>인터넷이나 네트워크 상에 있는 저장소</p>\n<h3>Git 원격 저장소 받아오기</h3>\n<p>기존 git 저장소를 복사하는 명령어를 활용해 원격 저장소를 불러올 수 있다. 이때 원격 저장소에서 <code class=\"language-text\">clone</code> 버튼을 통해 <code class=\"language-text\">Clone with HTTPS</code> 옵션으로 주소를 복사해 추가해주어야 한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">git clone 원격 저장소 주소</code></pre></div>\n<p>이후 다음 명령어로 연결할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">git remote add origin 원격 저장소 주소</code></pre></div>\n<p>또한, 다음 명령어를 통해 연결된 원격 저장소를 확인할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">git remote</code></pre></div>\n<p>추가적으로 원격 저장소를 어떤 원격 저장소가 있는지 살펴볼 수 있고, 원격 저장소의 이름을 변경할수도 원격 저장소를 삭제할수도 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">git remote show origin\r\ngit remote rename origin newName\r\ngit remote rm newName</code></pre></div>\n<blockquote>\n<p><code class=\"language-text\">git clone</code> 명령어를 실행하면 현재 폴더 내에 새로운 폴더를 하나 더 생성합니다. 따라서 현재 폴더를 저장소로 쓰고 싶다면 <code class=\"language-text\">git clone</code> 명령의 마지막에 <code class=\"language-text\">.</code> 을 찍어주면 됩니다.</p>\n</blockquote>\n<h3>Git 원격 저장소 동기화</h3>\n<p>원격 저장소에서 데이터를 가져와 로컬 데이터와 병합하기 위해 다음 명령어를 활용한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">git pull</code></pre></div>\n<p>이와 달리 다음 명령어를 통해 원격 저장소 데이터를 가져오면, 이후에 추가적인 작업이 필요하다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">git fetch\r\ngit log\r\ngit merge origin/master</code></pre></div>\n<p>즉, 데이터를 가져오기만 하기 때문에 추가적으로 변경된 파일을 확인한 후 병합해주어야 한다.</p>\n<blockquote>\n<p><code class=\"language-text\">pull</code>은 로컬 저장소에 있는 <code class=\"language-text\">master</code>를 자동으로 원격저장소에 있는 내용과 합쳐주는 역할을 수행합니다.\r\n<code class=\"language-text\">git pull</code>이 이루어지지 않는 경우는 보통 다른사람이 올린 <code class=\"language-text\">commit</code>의 내용과 내 컴퓨터에 존재하는 내용이 서로 충돌할 때입니다.\r\n이러한 현상은 하나의 브랜치에서 여러 사람이 동시에 작업하면 발생할 확률이 높아지게 됩니다.\r\n따라서 여러 개의 브랜치를 나누고 각자 브랜치에서 작업한 후에 웹호스팅 서비스에 존재하는 merge request로 하나씩 합쳐가는 방식을 사용하면 충돌이 일어나는 것을 막을 수 있고 매번 새롭게 merge해야하는 수고를 덜 수가 있습니다.</p>\n</blockquote>\n<h3>Git 원격 저장소 발행</h3>\n<p>로컬 저장소에서 작업한 내용을 원격 저장소에 반영하기 위해서는 다음 명령어를 활용해야 한다. 다만, 다른 사람이 먼저 <code class=\"language-text\">push</code>한 상태에서는 <code class=\"language-text\">push</code>할 수 없기 때문에 다른 개발자가 작업한 것을 병합부터 해야한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">git push origin master</code></pre></div>\n<h3><code class=\"language-text\">origin</code></h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">git remote add origin 원격 저장소 주소</code></pre></div>\n<p>위 명령어는 원격 저장소의 단축 이름을 <code class=\"language-text\">origin</code>으로 설정하는 것이다. 다른 이름으로 지정할 수도 있다. 다만, 기본적으로 만들어진 원격 저장소 이름은 <code class=\"language-text\">origin</code>이 기본값이기 때문에 복사한 저장소도 <code class=\"language-text\">origin</code>으로 통일된다. 이때 <code class=\"language-text\">-v</code> 옵션을 통해 지정한 저장소의 이름과 주소를 함께 볼 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">git remote -v</code></pre></div>","frontmatter":{"title":"[Elice] SW 엔지니어 트랙 2기 5일차 mini-log","date":"April 08, 2022","description":"Elice, SW, WEB, Frontend, Bootcamp, 이고잉, HTML, CSS, git, github, gitlab, command"}},"previous":{"fields":{"slug":"/20220407_elice/"},"frontmatter":{"title":"[Elice] SW 엔지니어 트랙 2기 4일차 mini-log"}},"next":null},"pageContext":{"id":"2f44cf90-cfd8-5170-a5b8-31dcc5361c0f","previousPostId":"0e03df8f-2b04-5d2a-a32f-2913126ba7d3","nextPostId":null}},
    "staticQueryHashes": ["2841359383","3257411868"]}